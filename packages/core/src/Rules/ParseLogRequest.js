/* @flow */

import Log from '../Log'
import Rule from '../Rule'

import type { Action, ParsedLog } from '../types'

function innerText (element: Object): string {
  return element.type === 'text'
    ? element.text
    : element.elements
      ? element.elements.map(innerText).join()
      : ''
}

export default class ParseLogRequest extends Rule {
  static parameterTypes: Array<Set<string>> = [new Set(['LogRequest'])]
  static defaultActions: Array<Action> = ['parse']
  static description: string = 'Parse files generated by logreq package.'

  async parse () {
    const output = await this.getResolvedOutput('$FILEPATH_0-ParsedLogRequest')
    if (!output) return false

    const parsedLog: ParsedLog = {
      messages: [],
      inputs: [],
      outputs: [],
      calls: [],
      requests: []
    }

    const contents: Object = await this.firstParameter.readXml()

    for (const requests of contents.elements.filter(element => element.name === 'requests')) {
      for (const request of requests.elements.filter(element => element.type === 'element' && element.attributes.active === '1')) {
        const shellRequest = {
          type: '',
          args: [],
          options: {},
          inputs: [],
          outputs: []
        }

        for (const part of request.elements.filter(element => element.type === 'element')) {
          switch (part.name) {
            case 'generic':
              shellRequest.type = innerText(part)
              break
            case 'cmdline':
              const { args, options } = Log.parseCommandLine(part.elements.map(innerText))
              shellRequest.args = args
              shellRequest.options = options
              break
            case 'input':
            case 'requires':
              shellRequest.inputs = shellRequest.inputs.concat(part.elements.map(innerText))
              break
            case 'output':
            case 'provides':
              shellRequest.outputs = shellRequest.outputs.concat(part.elements.map(innerText))
              break
          }
        }

        // if (shellRequest.inputs.length > 0) {
        //   shellRequest.inputs = await this.locateFiles(shellRequest.inputs)
        // }

        parsedLog.requests.push(shellRequest)
      }
    }

    output.value = parsedLog

    return true
  }
}
